---
title: "StackedBar_Flex24"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    theme:  
          version: 4
          bootswatch: litera
runtime: shiny

---

```{r setup, include=FALSE}

rm(list=ls())
### NOTES
# Converted all tibbles to data frames to get rid of phantom column name errors

### NAMING RULES
# Functions: FuncTest(dat1_there, dat2_here)
# Action buttons: button_PushMe
# User inputs: sel_SelectMe
# Lists, data frames, vectors, variables...: station_files_list, station_df,  station_vec, here_is_a_variable
# Data frame cols: df$ColThisOne, df$ColThatOne
# List elements: list$ElementOne, list$ElementTwo
# Reactive elements: rv$ThisOne, rv$ThatOne
# Temporary variables: temp_this_df
# Well panel id's: wp_FilterParkSite

#options(url.method = "wininet")
#options(repos="http://cran.revolutionanalytics.com")
#options(repos = c(CRAN = "https://cloud.r-project.org"))

### Load libraries -----
# Will automatically install any libraries it can't find
pkgs <- c("flexdashboard", 
              "shiny", 
              "knitr", 
              "odbc", # pull data from SQL server
              "leaflet", 
              "here",
              "plotly", 
              "tidyverse", 
              "plyr", 
              "sf",
              "readr",
              "magrittr",
              "bslib", 
              "ggplot2",
              "patchwork",
              "leaflet.extras", 
              "lubridate",
              "forcats",
              "httr", # use web services
              "rgdal", # to use readOGR
              "sp", # transform projections
              "purrr", # for applying functions to dplyr groups
              "dataMaid", # for data checks
              "shinyFiles", # for user to save files in specified location
              "RColorBrewer", # to display brewer palettes
              "shinyjs", # for easy functions that use JavaScript
              "stringr", # to detect text snippets
              "reactable",
              "reactablefmtr",
              "base", 
              "htmltools", 
              "ggthemes",
              "data.table", # for fast lag calcs
              "DT", # for interactive tables
              "cowplot", # to get legends from plots
              "crosstalk", # for SharedData
              "gridExtra", # for arranging plots and adding plot annotations (ggplotly can't do captions or subtitles)
              "RgoogleMaps", # for MaxZoom & MinZoom
              "leaflet.minicharts") # for pie charts in leaflet maps


installed_pkgs <- pkgs %in% installed.packages()
if (length(pkgs[!installed_pkgs]) > 0) install.packages(pkgs[!installed_pkgs],dep=TRUE, repos='http://cran.us.r-project.org') #repos is new line of code!!!! 
lapply(pkgs, library, character.only = TRUE)

invisible(lapply(pkgs, library, character.only = TRUE))

options(shiny.maxRequestSize=60*1024^2) #increase the file upload limit to 90MB.

rv <- reactiveValues(SeedlingSapling = NULL, SpeciesDiversity = NULL, Tree = NULL, CanopyCover = NULL, StandHeight = NULL, Genus = NULL, LatLong = NULL, Species_Cover = NULL, Cover_Class = NULL, Exotics = NULL, CWD = NULL, BroadGroup = NULL, CycleNumber = NULL)


#### might have to change the reactive value names??? read the shiny
temp_rv <- shiny::reactiveValues(
  df_rich = NULL, 
  plotly_tree = NULL, 
  df_treeplot = NULL, 
  df_treeyr = NULL,
  selected_richgroup = NULL, 
  constancy_final = NULL, 
  cwd_df = NULL, 
  cwd_obs = NULL, 
  cwd_countplot = NULL, 
  cwd_avgplot = NULL, 
  df_spcompbar = NULL, 
  bc = NULL, 
  nc = NULL
)
```

```{r}
#reading in csvs

trees <- read_csv(here::here("output", "CUPN_TreeBasics.csv")) #NEWNEW cycle tree basics
seedlingsapling <- read_csv(here::here("output", "CUPN_SeedlingSapling.csv")) #NEWNEW cycle seedling sapling
broadgroup <- read_csv(here::here("output", "CUPN_BroadGroup.csv")) #used to be broadgroup
# species_rich <- read_csv(here::here("Data_In","SpeciesDiversity_LongFormat_20230421.csv")) #waiting on new data from Tim
genus <- read_csv(here::here("output", "TaxaTable.csv"))
location <- read_csv(here::here("output", "Location_Table.csv")) #let's just call this LOCATION
genus_group <- read_csv(here::here("output", "Genus_grouping.csv"))
events <- read_csv(here::here("output", "CUPN_EventTable2.csv"))
```


```{r functions}
### Functions-----

#rounding function 
#stick to a certain function naming rule
round_df <- function(x, digits) {
    numeric_columns <- sapply(x, mode) == 'numeric'
    x[numeric_columns] <-  round(x[numeric_columns], digits)
    x
}

options(scipen=999)

#keeping only first letter of character
makeInitials <- function(charVec) {
  make.unique(vapply(strsplit(toupper(charVec), " "), 
                     function(x) paste(substr(x, 1, 1), collapse = ""), 
                     vector("character", 1L)))
}

#color palettes
Okabe_Ito <- c("#E69F00", "#56B4E9", "#009E73", '#CC6677',"#F0E442", "#0072B2", "#D55E00", 
               "#CC79A7", "#000000",'#DDDDDD', '#EE6678', '#99DDFF', 
               '#BBCC33', '#332288', '#882255', '#FFAABB')

okabe_ito <- c( "#0072B2", "#D55E00", 
               "#CC79A7", "#000000",  '#CC6677', '#BBCC33', '#99DDFF', 
                '#332288', '#882255', '#FFAABB', "#E69F00", "#56B4E9", "#009E73", "#F0E442")

viridis <- c("#fde725", "#5ec962", "#21918c","#3b528b","#440154")

jane <- c('#a5cee2', '#1f78b4', '#b2df8a', '#e7298b', '#33a02b', '#997dd4', '#000000', '#fc9a99','#e21a1c', '#fdbe6f', '#ff7f00', '#9c9c9c', '#cab2d6', '#6a3d9a', '#feff99', '#b15929')

# function to group by a plot, year and find the count of n
makefun <- function(data) {
  data %>% 
  dplyr::group_by(Plot_Code, Year) %>%
  dplyr::summarize(n())
  
}
##### css functions
integer_columns <- function(maxWidth = 60, ...) {
  colDef(maxWidth = maxWidth, align = "center",...)
}

with_tooltip <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help", title = tooltip, value)
}

# lists for organizing column orders
positions <- c("Tree", "Sapling", "Seedling")

col_group <- c("Plot_Code", "Plant_Code", "Start_Date", "Sample_Year", "Event_ID")

#Neesd to get ride of Network, Park, and Subunit, Change Start_Date to Sample Date?
common_columns <- c("Network_Code", "Park_Code", "Subunit_Code", "Plot_Code", "Start_Date", "Event_Type_Name", "Year") 
```

```{r}
func_processdata <- function(df, growth_form) {
  df %>%
    dplyr::mutate(Start_Date = as.Date(lubridate::mdy_hm(Start_Date)),
                  Sample_Year = as.factor(Sample_Year),
                  Growth_Form = growth_form)
}

df_genus <- genus %>% 
  dplyr::select(Plant_Code, Genus) 

df_events <- func_processdata(events, NA)

df_events %<>%
  dplyr::mutate(Subunit_Code = substr(Plot_Code, 1, 4))

df_trees <- func_processdata(trees, "Tree") %>%
  dplyr::filter(Status_Name == "Live Tree") %>%
  dplyr::mutate(BA_ha = ((pi * DBH^2) / 40000) / 0.04)          # df_trees and df_seedsap are slaying

df_seedsap <- func_processdata(seedlingsapling, NA)

 # new code for woody map _flex24
location %<>%
    dplyr::select(Park_Code, Subunit_Code, Plot_Code, Latitude, Longitude)

genus_grouping <-  if (!exists("genus_group")) {
  genus_grouping <- NULL
  } else { 
  genus_grouping <- genus_group
  }

```

```{r does stacked bar plot need this? Does it call to any of it?}
df_treedivsum <- df_trees %>% #----------Summing basal area per growth form, year, plot, and subunit 
  dplyr::group_by(Plot_Code, Start_Date, Event_ID, Sample_Year, Growth_Form) %>%
  dplyr::summarise(Sum = sum(BA_ha)) %>%
  tidyr::pivot_longer(cols = Sum, 
                      names_to = "Plant_Code", 
                      values_to = "Count")
  # tidyr::pivot_longer(cols = Sum, 
  #                     names_to = "Genus", 
  #                     values_to = "Count")   old code when GENUS was still included in the input data
  # is there a better way? Should we keep df_treediv and df_treedivsum separate?

df_treediv <- df_trees %>% #----------finding raw count of live trees per growth form, year, plot, and subunit - are we not taking genus into account?? just raw numbers?? for us just plant_code which DOOESSS reduce the amount of observatiosn not as much as if by genus hmmmmmmmmmmmmmmmm
  dplyr::group_by(Plot_Code, Start_Date, Event_ID, Sample_Year, Plant_Code, Growth_Form) %>%
  dplyr::summarize(Count = n()) %>%
  ungroup() %>%
  full_join(df_treedivsum)



func_seedsap <- function(df, form_col, total_col) {
  df %>%
    replace(is.na(.), 0) %>%
    dplyr::group_by(Plot_Code, Start_Date, Event_ID, Sample_Year, Plant_Code, Growth_Form = form_col) %>%
    dplyr::summarise(Count = sum({{total_col}}, na.rm = TRUE)) %>%
    ungroup()
}

df_mapsapdiv <- func_seedsap(df_seedsap %>% dplyr::mutate(Growth_Form = "Sapling"), "Sapling", Sapling_Total)

df_mapsapsum <- df_seedsap %>%
  dplyr::mutate(
    Growth_Form = "Sapling",
    Sapling01_BA =  (0.00007854 * (0.5)^2 ) * Sapling_0_1_DBH,
    Sapling12h_BA = (0.00007854 * (1.75)^2 ) * Sapling_1_2half_DBH,
    Sapling2h5_BA = (0.00007854 * (3.25)^2 ) * Sapling_2half_5_DBH ,
    Sapling510_BA = (0.00007854 * (7.5)^2 ) * Sapling_5_10_DBH
  ) %>%
  dplyr::group_by(Plot_Code, Start_Date, Event_ID, Sample_Year, Growth_Form) %>%
  dplyr::summarise(
    Sum = sum(Sapling01_BA, Sapling12h_BA, Sapling2h5_BA, Sapling510_BA, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  tidyr::pivot_longer(
    cols = Sum,
    names_to = "Plant_Code",
    values_to = "Count"
  )

df_sapdiv <- dplyr::full_join(df_mapsapdiv, df_mapsapsum) #-------joining count and basal area calculations for saplings

df_mapseeddiv <- func_seedsap(df_seedsap %>% dplyr::mutate(Growth_Form = "Seedling"), "Seedling", Seedling_Total)

df_mapseedsum <- df_mapsapsum %>%
  dplyr::mutate(Growth_Form = "Seedling", 
                Count = 50) # so much easier lol

df_seeddiv <- dplyr::full_join(df_mapseeddiv, df_mapseedsum) 


df_spdiv <-  Reduce(function (...) { merge(..., all = TRUE) },  #full join idk why I can't just do a regular left join....
                        list(df_treediv, df_sapdiv, df_seeddiv))
#### end of code within the flexdashboard

genus_grouping <-  if (!exists("genus_group")) {
  genus_grouping <- NULL
  } else { 
  genus_grouping <- genus_group
  }


```

```{r not needed,matches the inputs from woody map}
############3 9/14/24 something to note is that I probably need to keep in the even_ID to link with location data and sampling date - just a check!!!!!!!!! 
# df_trees1 <- trees %>%
#   dplyr::mutate(Start_Date = lubridate::mdy_hm(Start_Date),
#                 Start_Date = as.Date(Start_Date),
#                 Sample_Year = as.factor(Sample_Year)) %>%
#   dplyr::filter(Status_Name == "Live Tree") %>%
#   dplyr::mutate(BA_ha = ((pi * DBH^2) /40000)/0.04,
#                 Growth_Form = "Tree")
# 
# df_seedsap2 <- seedlingsapling %>%
#   dplyr::mutate(Start_Date = lubridate::mdy_hm(Start_Date),
#                 Start_Date = as.Date(Start_Date),
#                 Sample_Year = as.factor(Sample_Year))
```


```{r}
df_sap <- df_seedsap %>%
    dplyr::select(all_of(col_group), 
                  Plant_Code,
                  Sapling_Total) %>%
    dplyr::group_by(across(all_of(col_group))) %>%
    dplyr::summarize(Sapling = sum(Sapling_Total))
  
  df_seed <- df_seedsap %>%
    dplyr::select(all_of(col_group), 
                  Plant_Code, 
                  Seedling_Total) %>%
    dplyr::group_by(across(all_of(col_group))) %>%
    dplyr::summarize(Seedling = sum(Seedling_Total))
  
  df_treesp <- df_trees %>%
    dplyr::group_by(across(all_of(col_group)), Plant_Code) %>%
    dplyr::summarise(Tree = n())
  
    df_treefull <- Reduce(function (...) { merge(..., all = TRUE) },  # Full join
                           list(df_sap,
                                df_seed,
                                df_treesp))
    
    df_treefull %<>%
      tidyr::pivot_longer(cols = c(Seedling, Sapling, Tree), 
               names_to = "Strata", 
               values_to = "Count")
```

```{r}
all_events <- events %>%
  left_join(broadgroup) %>%
  dplyr::filter(Event_Type != "QA/QC")%>% 
  left_join(location %>% dplyr::select(Park_Code, Subunit_Code, Plot_Code), by = "Plot_Code")

```


```{r}
# input <- list()
# input$stack_spatialunit <- "Subunit_Code"
# input$stack_userunit <- "BIRT"
# input$stack_season <- "Sample_Year"
# input$stack_year <- "2011"
# input$stack_spatialhabitat <- "Group_B_Common_Name"
# input$stack_userhabitat <- "Successional Tuliptree Forest (Rich Type)"
# input$stack_spgroup <- "Plant_Code" # options are Genus and plant code
# input$stack_usergroup <- "Group22" #group x, y, z


#this code is selecting for the spatial scale, for plotting bar chats we can either look at everything across the entire plot, ORRRR  we can look within a park/subunit and select for the smaller grouping
 if (input$stack_spatialhabitat == "All" & input$stack_userhabitat == "All") {
   nplot <- all_events %>%
     dplyr::filter(!!as.name(input$stack_spatialunit) == input$stack_userunit) %>%
     distinct(!!as.name(input$stack_season), Plot_Code, Event_ID)
  

 } else {
   nplot <- all_events %>%
     dplyr::filter(!!as.name(input$stack_spatialunit) == input$stack_userunit) %>%
     dplyr::filter(!!as.name(input$stack_spatialhabitat) == input$stack_userhabitat) %>%
     distinct(!!as.name(input$stack_season), Plot_Code, Event_ID)
 } 

stack_sequence <- nplot %>%
  dplyr::filter(!!as.name(input$stack_season) == input$stack_year) %>%
  pull(Event_ID)


#this code is selecting for if there is a different type of SPECIES GROUPING that we want either GENUS (top 8) or by another grouping based on species and a higher group

# woodystacktop_species <- 
if (input$stack_spgroup == "Genus" & input$stack_usergroup == "Genus") {

df_stacktop <- df_treefull %>%
  dplyr::filter(Event_ID %in% stack_sequence, 
                Strata == "Tree") %>%
  left_join(df_genus) %>%
  dplyr::group_by(!!as.name(input$stack_spgroup)) %>%     #either group by plant code or by a group of selected genuses????
  dplyr::summarize(tree_obs = n()) %>%
  ungroup() %>%
  top_n(7, tree_obs) %>%
  droplevels(.)

woodystacktop_species <- df_stacktop %>%
                        distinct(!!as.name(input$stack_spgroup)) %>%  # use !!as.name to refer to the column
                        pull(.)

woodystacktop_species <- as.character(c(as.character(woodystacktop_species), "Other"))

  } else {
    # input$stack_spgroup <- "Plant_Code" testing to make sure plant_code acutally works
    genus_group <- genus_grouping 
    # %>%
      # select(!!as.name(input$stack_spgroup), everything()) ### I actually think this doesn't do anything

    woodystacktop_species <- unique(genus_group[[input$stack_spgroup]])

    woodystacktop_species <- as.character(c(as.character(woodystacktop_species), "Other"))

    df_treefull %<>%
      full_join(genus_grouping) %>%
      dplyr::select(-Genus)

  }


s <- df_treefull %>%
  dplyr::filter(Event_ID %in% stack_sequence) %>%
  left_join(df_genus) %>%
  dplyr::mutate(Subunit_Code = substr(Plot_Code, 1, 4),
                Plant_Code = as.factor(Plant_Code)) %>%
  dplyr::mutate(Plot_Genus = forcats::fct_other(.[[input$stack_spgroup]], #works for genus genus and genus group
                                                   keep = woodystacktop_species, ### this could be an input
                                                   other_level = 'Other')) %>%
  dplyr::mutate(Plot_Genus = as.factor(Plot_Genus)) %>% 
  dplyr::mutate(!!as.name(input$stack_usergroup) := case_when(
    Plot_Genus == "Other" ~ "Other", 
    TRUE ~ .[[input$stack_usergroup]])) %>%
  dplyr::group_by(Sample_Year, Strata,
                  !!as.name(input$stack_usergroup)) %>%
  dplyr::summarise(Count = sum(Count)) %>%
  ungroup() 

stack_expan <- spdiv %>%
  dplyr::select(Subunit_Code, Event_ID, Plot_Code, Sample_Year, Growth_Form) %>%
  distinct() %>%
  dplyr::mutate(
    # Dynamically create a column based on input$map_usergroup
    !! input$map_usergroup := "Other",  
    Count = 0  # Add 'Count' column with value 0
  )



########### Woody MAp example
spdiv <- df_spdiv %>%
  left_join(df_genus, by = "Plant_Code") %>%
  dplyr::mutate(Subunit_Code = substr(Plot_Code, 1, 4),
                Plant_Code = as.factor(Plant_Code)) %>%
  dplyr::mutate(Plot_Genus = forcats::fct_other(.[[input$map_spgroup]], #works for genus genus and genus group
                                                   keep = woodymptop_species, ### this could be an input
                                                   other_level = 'Other')) %>%
  dplyr::mutate(Plot_Genus = as.character(Plot_Genus)) %>%
  dplyr::mutate(Genus = case_when(
    Plant_Code == "Sum" ~ "Sum",
    TRUE ~ Genus)) %>%
  dplyr::mutate(Plot_Genus = case_when(
    Plant_Code == "Sum" ~ "Sum",
    TRUE ~ Plot_Genus)
  ) %>%
  dplyr::mutate(Plot_Genus = as.factor(Plot_Genus)) %>% 
  dplyr::mutate(!!as.name(input$map_usergroup) := case_when(
    Plot_Genus == "Sum" ~ "Sum", 
    Plot_Genus == "Other" ~ "Other", 
    TRUE ~ .[[input$map_usergroup]])) %>%
  dplyr::group_by(Subunit_Code, Event_ID, Plot_Code, Sample_Year, Growth_Form, #Plot_Genus,
                  !!as.name(input$map_usergroup)) %>%
  dplyr::summarise(Count = sum(Count)) %>%
  ungroup() 

stack_expan <- spdiv %>%
  dplyr::select(Subunit_Code, Event_ID, Plot_Code, Sample_Year, Growth_Form) %>%
  distinct() %>%
  dplyr::mutate(
    # Dynamically create a column based on input$map_usergroup
    !! input$map_usergroup := "Other",  
    Count = 0  # Add 'Count' column with value 0
  )

spdiv %<>%
  full_join(mp_expan) %>%
  dplyr::group_by(Subunit_Code, Event_ID, Plot_Code, Sample_Year, Growth_Form, #Plot_Genus,
                  !!as.name(input$map_usergroup)) %>%
  dplyr::summarise(Count = sum(Count)) %>%
  ungroup() 
  
  
############
  
  
  
  
  
  
  
  
  
  
  
  
  


   
    # prop_species <- df_treefull %>%
    #     dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit, 
    #                   Strata == "Tree") %>% # this is a new line of code looking at most abundant tree species ### there might be associated errors with this
    #     dplyr::group_by(Strata, !!as.name(species_group)) %>%
    #     dplyr::summarize(Sum = sum(Count)) %>%
    #     top_n(7, Sum) %>%
    #     droplevels(.) %>%
    #     ungroup()
    

   
################## Code below belongs within a reactive ##################
    

# WE ARE PULLING FROM ALL_EVENTS - SELECTING AND FILTERING PLOTS FROM THERE AND ALLOWING A SELECTION OF EVENT_IDS
    # df_broadgroup <- broadgroup %>% #### this is one of the input locations
    #   dplyr::filter(Group_A == "Shortleaf Pine - Oak Forest", 
    #                 Sample_Year %in% cycle_year) %>%
    #   distinct(Plot_Code) %>%
    #   pull(.)
    

      
  #%>%
      
    # df_treespfull <- df_treespfull %>%
    #   dplyr::mutate_if(is.numeric, ~replace(., is.na(.), 0)) %>%
    #   pivot_longer(cols = c(Seedling, Sapling, Tree), 
    #            names_to = "Strata", 
    #            values_to = "Count") # %>%
    #  
      
      df_treespfull <- df_treespfull %>% 
        dplyr::group_by(Genus, Strata) %>%
      # dplyr::group_by(across(all_of(col_group)), Genus) %>%
        dplyr::summarise(Count = sum(Count)) %>%
        ungroup()####              # better order for calculating post filtering
    
    ls_toptrees <- df_treespfull %>%
      dplyr::filter(Strata == "Tree", 
                    Count != "0") %>%
      dplyr::slice_max(Count, n = 7, with_ties = FALSE) %>%
      droplevels(.) %>% #hrm eventually useful?
      ungroup() # hrm probably usefull
      
     ls_toptrees <- unique(ls_toptrees[["Genus"]]) #######needs to be in double brackets!!!
     ls_toptrees <- append(ls_toptrees, "Other") 
     ls_toptrees <- as.character(ls_toptrees)
     
     
     df_treefiltered <- df_treespfull %>% # rv$df_treeyr %>%
        dplyr::mutate(species_group_og = forcats::fct_other(Genus, 
                                                  keep = ls_toptrees, 
                                                  other_level = "Other")) %>%
        # dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
        dplyr::group_by(Strata, species_group_og) %>%
        dplyr::summarize(Sum = sum(Count)) %>%
        ungroup()
     
     plot_treefiltered <- df_treefiltered %>%
       tidyr::pivot_wider(names_from = species_group_og, 
                          values_from = Sum)

     color_pallete_function <- colorRampPalette(
       colors = jane, #Okabe_ito
       space = "Lab")
     
     num_colors <- nlevels(df_treefiltered$species_group_og)
     janepalette <- color_pallete_function(num_colors)
     janepalette <- setNames(janepalette, levels(df_treefiltered$species_group_og))
     janepalette["Other"] <- "#333333"
     
     page_height = 550
    
     plot_tree <- df_treefiltered %>%
       ggplot2::ggplot(aes(x = Strata, 
                           y = Sum, 
                           fill = species_group_og)) + 
       geom_bar(width = 0.45, 
                position = "fill", 
                stat = "identity") + 
       theme_clean() + 
       labs(x = "", y = "Proportion of genera") + 
       ggtitle("") + #ggtitle(paste0(input$stack_cycle, ": ", input$stack_year, ", ", input$stack_unit, ", ", input$stack_association))
       theme(plot.title = element_text(lineheight = 3, 
                                       face = "bold", 
                                       color = "black", 
                                       size = 12)) + 
       scale_fill_manual(values = janepalette[unique(df_treefiltered$species_group_og)],
                      drop = TRUE) +
       scale_x_discrete(limits = positions) 
       
    
```






```{r prop tree 2}
# input <- list()
# input$stack_spatialscale <- "Subunit_Code"
# input$stack_unit <- "BIRT"
# input$stack_year <- "2011"
# input$stack_association <- "Successional Tuliptree Forest (Rich Type)"
# input$stack_spgroup <- "Genus"
# input$stack_cycle <- "Year"
# input$stack_habitatgroup <- "Association_CommonName"

observeEvent(eventExpr = input$button_UpdatePlots, {
  
  cat("Line0")

 shiny::req(!is.null(input$stack_spatialscale), !is.null(input$stack_unit), !is.null(input$stack_association), !is.null(tree_basics), !is.null(input$stack_year), !is.null(input$stack_spgroup), !is.null(input$stack_cycle), !is.null(input$stack_habitatgroup))
  
  cat("Line1")
  withProgress(message = "Just a moment", detail = "Generating stacked bar chart...", value = 0, {
  
  species_group <- input$stack_spgroup 
  species_group_name <- input$stack_spgroup
  habitat_group <- input$stack_habitatgroup
  
  tree_barplot <- func_tree(tree_basics, input$stack_spgroup)
  sapling_barplot <- func_sap(seedling_sapling, input$stack_spgroup)
  seedling_barplot <- func_seed(seedling_sapling, input$stack_spgroup)
  
  tree_full <- Reduce(function (...) { merge(..., all = TRUE) },  # Full join
                           list(seedling_barplot,
                                sapling_barplot,
                                tree_barplot))

  tree_full <- left_join(tree_full, broadgroup, by = c("Plot_Code","Event_Type_Name", "Start_Date", "Year")) %>%
    dplyr::mutate_if(is.numeric, ~replace(., is.na(.), 0)) %>%
    pivot_longer(cols = c(Seedling, Sapling, Tree), 
               names_to = "Strata", 
               values_to = "Count") 
  
rv$df_treeyr <-  #rv$df_treeyr
  if  (input$stack_cycle == "Year") {
    
  tree_full %>%
    dplyr::filter(Year %in% input$stack_year)
  
  } else { # could maybe just be an else statement
   
  stack_cycle <- tree_basics %>%
    dplyr::select(Start_Date, Plot_Code, Cycle) %>%
    distinct()
      
  df_woody <- left_join(tree_full, stack_cycle, by = c("Plot_Code", "Start_Date"))
    
  df_woody %>% 
    dplyr::filter(Cycle == input$stack_year) }

cat("Line2")


  if (input$stack_association == "All") {
      nplot <- rv$df_treeyr %>% # rv$df_treeyr %>% 
        dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
        distinct(Plot_Code)
        
      # prop_species <- tree_full %>%
      prop_species <- tree_barplot %>%
        dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
        dplyr::group_by(Strata, !!as.name(species_group)) %>%
        dplyr::summarize(Sum = sum(Count)) %>%
        top_n(7, Sum) %>%
        droplevels(.) %>%
        ungroup()
      
      prop_species <- unique(prop_species[[species_group]]) #######needs to be in double brackets!!!
      prop_species <- append(prop_species, "Other")
      prop_species <- as.character(prop_species) #might be redundant at this point
      
      
      df_tree <- rv$df_treeyr %>% # rv$df_treeyr %>%
        dplyr::mutate(species_group_og = forcats::fct_other(rv$df_treeyr[[species_group]], 
                                                  keep = prop_species, 
                                                  other_level = "Other")) %>%
        dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
        dplyr::group_by(Strata, species_group_og) %>%
        dplyr::summarize(Sum = sum(Count)) %>%
        ungroup()
      
  } else {

cat("Line3")
    
nplot <- rv$df_treeyr %>% # rv$df_treeyr %>%
   dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
   dplyr::filter(!!as.name(habitat_group) %in% input$stack_association) %>%
   distinct(Plot_Code)
  
    
 prop_species <- tree_full %>%
  dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
  dplyr::filter(!!as.name(habitat_group) %in% input$stack_association) %>%
  dplyr::group_by(!!as.name(habitat_group), Strata, !!as.name(species_group)) %>%
  dplyr::summarize(Sum = sum(Count)) %>%
  top_n(7, Sum) %>%
  droplevels(.) %>%
  ungroup()

 prop_species <- unique(prop_species[[species_group]]) 
 prop_species <- append(prop_species, "Other")
 prop_species <- as.character(prop_species)

df_tree <- rv$df_treeyr %>% #  rv$df_treeyr %>%
    dplyr::mutate(species_group_og = forcats::fct_other(rv$df_treeyr[[species_group]], 
                                                  keep = prop_species, 
                                                  other_level = "Other")) %>%
    dplyr::filter(!!as.name(input$stack_spatialscale) == input$stack_unit) %>%
    dplyr::filter(!!as.name(habitat_group) %in% input$stack_association) %>%
    dplyr::group_by(!!as.name(habitat_group), Strata, species_group_og) %>%
    dplyr::summarize(Sum = sum(Count)) %>%
    ungroup()
  }

cat("Line4")

rv$df_tree <- df_tree %>% # rv$df_treeyr <- df_tree # 
  tidyr::pivot_wider(names_from = species_group_og, 
                     values_from = Sum)

color_pallete_function <- colorRampPalette(
  colors = jane, #Okabe_ito
  space = "Lab")

num_colors <- nlevels(df_tree$species_group_og)
janepalette <- color_pallete_function(num_colors)
janepalette <- setNames(janepalette, levels(df_tree$species_group_og))
janepalette["Other"] <- "#333333"

page_height = 550

# npage <- sum(count(p)$freq))

cat("Line5")

plot_tree <- df_tree %>%
  ggplot(aes(x = Strata,
             y = Sum,
             fill = species_group_og)) +
  geom_bar(width = 0.45, 
           position = "fill",
           stat = "identity") +
  theme_clean() +
  labs(x = "", y = "Proportion of genera") + 
  ggtitle(paste0(input$stack_cycle, ": ", input$stack_year, ", ", input$stack_unit, ", ", input$stack_association)) + theme(plot.title = element_text(lineheight=3, face="bold", color="black", size=12)) +
  # geom_text(aes(label = Genus), position = position_fill(vjust = 0.5), color = "#FFFFFF") + # HAS ISSUES
  scale_fill_manual(values = janepalette[unique(df_tree$species_group_og)],
                      drop = TRUE) +
  scale_x_discrete(limits = positions) 

cat("Line6")

  rv$plotly_tree <-
 # if (x == 1 ) {
       ggplotly(plot_tree, height = page_height) %>% #, height = page_height
  layout(margin = list(
    l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 40),
  legend = list(orientation = 'h',
                xanchor = "center",
                borderwidth = 0.5,
                x = 0.5,
                y = -0.2,
                title = "",
                # title = list(font = list(size = 12)),
                font = list(size = 11)),
  annotations = list(text = paste0("Number of Surveyed Plots:", sum(count(nplot)$freq), "<br>Total densities of genera in all plots of the selected subunit-community group <br> (seedlings and saplings summed at 1 and 10 m2 quadrats; <br> trees summed at the 400m2 plot level)"), #added comma
                     font = list(size = 12), 
                     showarrow = FALSE,
                            xref = 'paper', x = 1.02,
                            yref = 'paper', y = 1.3)
  )
  
  
# saveRDS(isolate(reactiveValuesToList(input)), paste0("stackplot_input.RDS"))
# saveRDS(isolate(reactiveValuesToList(rv)), paste0("stackplot_rv.RDS"))
  })
 })


```



